\ProvidesPackage{math}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[algoruled,vlined,linesnumbered]{algorithm2e}



\usepackage{listings}

\newcommand{\term}[1]{{\bfc{\textit{#1}}}}
\newcommand{\termx}[1]{{\bfc{\textit{#1}}}}


%%%%%%%%%%%%%%%%%%%
%% LOGIC / SETS %%%
%%%%%%%%%%%%%%%%%%%

\newcommand{\True}{\ensuremath{\top}}
\newcommand{\False}{\ensuremath{\bot}}

\newcommand{\cbrace}[1]{\ensuremath{ \left\{#1\right\} }}
\newcommand{\pbrace}[1]{\ensuremath{ \left(#1\right) }}
\newcommand{\mbrace}[1]{\ensuremath{ \left[#1\right] }}
\newcommand{\gbrace}[1]{\ensuremath{ \left\lgroup#1\right\rgroup }}


\makeatletter
\newcommand{\se}[1]{%
  (\ensuremath{#1}\se@checknextarg}
\newcommand{\se@checknextarg}
{\@ifnextchar\bgroup{\se@gobblenextarg}{)}}
\newcommand{\se@gobblenextarg}[1]
{\ensuremath{\:{#1}}\@ifnextchar\bgroup{\se@gobblenextarg}{)}}
\makeatother

\newcommand{\sefun}[1]{\se{\mathtt{#1}}}
\newcommand{\senil}[0]{\mathtt{nil}}

\newcommand{\seand}[0]{\sefun{and}}
\newcommand{\seor}[0]{\sefun{or}}
\newcommand{\senot}[0]{\sefun{not}}


\newcommand{\sexp}[2]{
\ifx&#2&%
\ensuremath{\left(\texttt{#1}\right)}
\else
\ensuremath{\left(\texttt{#1}\ #2\right)}
\fi}

\newcommand{\sexpt}[2]{
  \ensuremath{\left(\texttt{#1}\ #2\right)}
}
\newcommand{\semul}[1]{\sexpt{*}{#1}}
\newcommand{\seadd}[1]{\sexpt{+}{#1}}
\newcommand{\sediv}[2]{\sexpt{/}{#1\ #2}}
\newcommand{\sesin}[1]{\sexpt{sin}{#1}}
\newcommand{\secos}[1]{\sexpt{cos}{#1}}
\newcommand{\seexpt}[2]{\sexpt{expt}{#1\ #2}}
\newcommand{\seexp}[1]{\sexpt{exp}{#1}}
\newcommand{\seln}[1]{\sexpt{ln}{#1}}



\newcommand{\sequote}[1]{\texttt{'}{#1}}
\newcommand{\sebackquote}[1]{\texttt{`}{#1}}
\newcommand{\secomma}[1]{\texttt{,}{#1}}
\newcommand{\secommaa}[1]{\texttt{\Accent{,}}{#1}}
\newcommand{\secommaat}[1]{\texttt{,@}{#1}}
\newcommand{\secommaata}[1]{\texttt{\Accent{,@}}{#1}}


\newcommand{\sekw}[1]{\texttt{\bf{#1}}}

\newcommand{\emptystring}{{\ensuremath{\boldsymbol{\varepsilon}}}}

\newcommand{\setbuilder}[2]{\cbrace{\left.{#1}\ \right.\left|\  {#2} \right.}}
\newcommand{\xor}{\oplus}
\newcommand{\intset}{\mathbb{Z}}
\newcommand{\natset}{\mathbb{N}}
\newcommand{\boolset}{\mathbb{B}}
\newcommand{\realset}{\mathbb{R}}
\newcommand{\faedge}[3]{\ensuremath{{#1}\xrightarrow{#2}{#3}}}

\newcommand{\langsym}{{\mathcal{L}}}
\newcommand{\lang}[1]{{\ensuremath{\langsym\left(#1\right)}}}
\newcommand{\langacc}[1]{{\ensuremath{\langsym_{\rm acc}\left(#1\right)}}}
\newcommand{\langrej}[1]{{\ensuremath{\langsym_{\rm rej}\left(#1\right)}}}

\newcommand{\regset}{{\ensuremath{\mathcal{R}}}}
\newcommand{\cfset}{{\ensuremath{\mathcal{C}}}}
\newcommand{\recset}{{\ensuremath{\mathcal{T}_{\rm D}}}}
\newcommand{\reset}{{\ensuremath{\mathcal{T}_{\rm R}}}}
\newcommand{\alangset}{{\ensuremath{\mathcal{L}_{\rm all}}}}

%\newcommand{\powerset}[1]{\ensuremath{2^{#1}}}
\newcommand{\powerset}[1]{\ensuremath{\mathcal{P}\left({#1}\right)}}
\newcommand{\iseq}{\stackrel{?}{=}}
\newcommand{\isin}{\stackrel{?}{\in}}
\newcommand{\issubseteq}[0]{\stackrel{?}{\subseteq}}

\newcommand{\langmark}[1]{{\ensuremath{\langsym_m\left(#1\right)}}}
\newcommand{\langgen}[1]{{\ensuremath{\langsym_g\left(#1\right)}}}

\newcommand\Union[2]{\ensuremath{\bigcup\limits_{#1}{#2}}}
\newcommand{\angry}[1]{\textcolor{angrycolor}{#1}}
\newcommand\undercmt[2]{\angry{\underbrace{\textcolor{black}{#1}}_{\textcolor{angrycolor}{#2}}}}
\newcommand\overcmt[2]{\angry{\overbrace{\textcolor{black}{#1}}^{\textcolor{angrycolor}{#2}}}}

\newcommand\aunderline[1]{\angry{\underline{\textcolor{black}{#1}}}}
\newcommand\aboxed[1]{\angry{\boxed{\textcolor{black}{#1}}}}

\renewcommand\complement[1]{\ensuremath{\overline{#1}}}
\newcommand\preclose[1]{\ensuremath{\widetilde{#1}}}


\newcommand{\contspace}[1]{{\mathcal{#1}}}

\newcommand{\statespace}[0]{{\mathcal{Q}}}
\newcommand{\actspace}[0]{{\mathcal{U}}}

%\usepackage{xspace}
%\newcommand{\TikZ}{Ti\textit{k}Z\xspace}
\newcommand{\TikZ}{Ti\emph{k}Z}

\newcommand{\dessupervise}[2]{#1/#2}

\newcommand{\suplanggen}[2]{\langgen{\dessupervise{#1}{#2}}}
\newcommand{\suplangmark}[2]{\langmark{\dessupervise{#1}{#2}}}


\newcommand{\folid}[1]{\texttt{#1}}
\newcommand{\folpred}[2]{\folid{#1}\left(#2\right)}
\newcommand{\folpredx}[2]{\folid{#1}\left(\folid{#2}\right)}
\newcommand{\folfunp}[2]{\folid{#1-#2}}
\newcommand{\folfun}[2]{\folid{#1}\left(#2\right)}



%%%%%%%%%%%%%%%
%% Sequences %%
%%%%%%%%%%%%%%%

% \newcommand{\seqbegin}[0]{\left(}
% \newcommand{\seqend}[0]{\right)}
% \newcommand{\seqsep}[0]{,\ }

% 1: first element
% 2: middle elements
% 3: last element

% \newcommand{\seq}[3]{\ensuremath{\seqbegin{#1}\seqsep{#2}{#3}\seqend}}
% \newcommand{\seqelt}[1]{{#1}\seqsep}
% \newcommand{\sequnit}[1]{\seqbegin{#1}\seqend}
% \newcommand{\seqempty}[0]{\seqbegin\seqend}


% \makeatletter
% \newcommand{\sequence}[1]{%
%   \seqbegin{#1}\sequencelist@checknextarg}
% \newcommand{\sequencelist@checknextarg}
% {\@ifnextchar\bgroup{\sequencelist@gobblenextarg}{\seqend}}
% \newcommand{\sequencelist@gobblenextarg}[1]
% {{{\seqsep}{#1}}\@ifnextchar\bgroup{\sequencelist@gobblenextarg}{\seqend}}
% \makeatother



%%%%%%%%%%%%%%%%%%%%%
%% Finite Automata %%
%%%%%%%%%%%%%%%%%%%%%

\newcommand{\fatranssym}[0]{\delta}
\newcommand{\fatrans}[2]{\fatranssym\left(#1,#2\right)}

\newcommand{\faetranssym}[0]{\hat{\delta}}
\newcommand{\faetrans}[2]{\faetranssym\left(#1,#2\right)}

%%%%%%%%%%%%%%
%% Grammars %%
%%%%%%%%%%%%%%

%\newcommand{\nonterm}[1]{\ensuremath{\langle\DataSty{#1}\rangle}}
\newcommand{\nonterm}[1]{\ensuremath{\langle{#1}\rangle}}
\newcommand{\nontermtxt}[1]{\ensuremath{\langle{\text{#1}}\rangle}}
\newcommand{\tokenleft}[0]{\left[}
\newcommand{\tokenright}[0]{\right]}
\newcommand{\token}[1]{\ensuremath{\tokenleft{#1}\tokenright}}
\newcommand{\terminal}[1]{\ensuremath{\DataSty{``#1''}}}
\newcommand{\terminalm}[1]{\ensuremath{\text{``}{#1}\text{''}}}

\newcommand{\nonterma}[1]{\Accent{\nonterm{#1}}}
\newcommand{\tokena}[1]{\Accent{\token{#1}}}

\newcommand{\nontermtxta}[1]{\Accent{\nontermtxt{#1}}}
\newcommand{\tokentxta}[1]{\Accent{\tokentxt{#1}}}

\newcommand{\nontermt}[1]{\ensuremath{\langle\textrm{#1}\rangle}}
\newcommand{\tokentxt}[1]{\ensuremath{\token{\text{#1}}}}
\newcommand{\tokent}[1]{\tokentxt{#1}}

\newcommand{\nontermm}[1]{\ensuremath{\langle{#1}\rangle}}
\newcommand{\tokenm}[1]{\ensuremath{\left[{#1}\right]}}


\newenvironment{grammar}{\begin{eqnarray*}}{\end{eqnarray*}}

\newcommand{\bnfprodx}[2]{\ensuremath{{#1} &
    \rightarrow &
    #2 \nonumber }}

\newcommand{\bnfprod}[2]{\ensuremath{\nonterm{#1} &
    \rightarrow &
    #2 \nonumber }}

\newcommand{\bnfprodtxt}[2]{\ensuremath{\nontermtxt{#1} &
    \rightarrow &
    #2 \nonumber }}

\newcommand{\bnfproda}[2]{\ensuremath{\nonterma{#1} &
    \color{angrycolor}{\rightarrow} &
    #2 \nonumber }}

\newcommand{\bnfprodaa}[2]{\ensuremath{\nonterma{#1} &
    \color{angrycolor}{\rightarrow} &
    \color{angrycolor}{#2} \nonumber }}

\newcommand{\bnfprodm}[2]{\ensuremath{\nontermm{#1} & \rightarrow & #2
    \nonumber }}

\newcommand{\bnfprodt}[2]{\ensuremath{\nontermt{#1} & \rightarrow & #2
    \nonumber }}

\newcommand{\bnfalt}[1]{\ensuremath{ & \arrowvert & #1 \nonumber}}
\newcommand{\bnfalta}[1]{\ensuremath{ & \Accent{\arrowvert} &
    \Accent{#1} \nonumber}}

\newcommand{\firstset}[1]{\ensuremath{\textsc{first}\left(#1\right)}}
\newcommand{\followset}[1]{\ensuremath{\textsc{follow}\left(#1\right)}}
\newcommand{\derives}[1]{{\stackrel{#1}{\leadsto}}}
\newcommand{\derivesquad}[1]{{\quad\stackrel{#1}{\leadsto}\quad}}
\newcommand{\nderives}[0]{{\stackrel{*}{\leadsto}}}

\newcommand{\Axleadsto}[1]{{\textcolor{Accentcolor}{\stackrel{#1}{\leadsto}}}}
\newcommand{\Acancelto}[2]{{\textcolor{Accentcolor}{\cancelto{#1}{\textcolor{black}{#2}}}}}


\newcommand{\childtoken}[1]{child{node{\token{#1}}}}
\newcommand{\nodenonterm}[1]{node{\nonterm{#1}}}
\newcommand{\nodetoken}[1]{node{\token{#1}}}
\newcommand{\nodenontermt}[1]{node{\nontermt{#1}}}
\newcommand{\nodenontermm}[1]{node{\nontermm{#1}}}

\newcommand{\discstep}[2]{\ensuremath{{#1}^{[{#2}]}}}

%%%%%%%%%
%% PDA %%
%%%%%%%%%


% q0, sigma, g0, g1, q1
\newcommand{\pdaedge}[5]{%
\ensuremath{{#1}\xrightarrow{{#2},\ {#3}\rightarrow{#4}}{#5}}
}

\newcommand{\pdalbl}[3]{%
  \ensuremath{{#1},\ {#2}\rightarrow{#3}}
}

% \newcommand{\pdaedge}[5]{%
% \ensuremath{\delta\left(#1,#2,#3\right) = \left(#5,#4\right)}
% }

%%%%%%%%%%%%%%%%%%%%%
%% Turing Machines %%
%%%%%%%%%%%%%%%%%%%%%

\newcommand{\blanksym}[0]{\ensuremath{\sqcup}}
\newcommand{\tmstates}[0]{\ensuremath{Q}}
\newcommand{\tmstate}[0]{\ensuremath{q}}
\newcommand{\tmstart}[0]{\ensuremath{\tmstate_0}}
\newcommand{\tmaccept}[0]{\ensuremath{\tmstate_{\rm acc}}}
\newcommand{\tmreject}[0]{\ensuremath{\tmstate_{\rm rej}}}
\newcommand{\tmtapealpha}[0]{\ensuremath{\Gamma}}
\newcommand{\tminputalpha}[0]{\ensuremath{\Sigma}}
\newcommand{\tmleft}[0]{\ensuremath{{\texttt{L}}}}
\newcommand{\tmright}[0]{\ensuremath{{\texttt{R}}}}

\newcommand{\tmerw}[3]{\ensuremath{#1\rightarrow #2,#3}}
\newcommand{\tmerwn}[3]{\ensuremath{\cbrace{#1}\rightarrow #2,#3}}
\newcommand{\tmero}[2]{\ensuremath{#1\rightarrow #2}}
\newcommand{\tmeron}[2]{\ensuremath{\cbrace{#1}\rightarrow #2}}

\newcommand{\tmconfstart}[0]{\ensuremath{\discstep{C}{0}}}
\newcommand{\tmconfaccept}[0]{\ensuremath{\mathcal{C}_{\rm acc}}}
\newcommand{\tmconfreject}[0]{\ensuremath{\mathcal{C}_{\rm rej}}}


%%%%%%%%%%%%
%% Lambda %%
%%%%%%%%%%%%

\makeatletter
\newcommand{\lmtuple}[1]{%
  \ensuremath{({#1}}\lmtuple@checknextarg}
\newcommand{\lmtuple@checknextarg}
{\@ifnextchar\bgroup{\lmtuple@gobblenextarg}{\ensuremath{)}}}
\newcommand{\lmtuple@gobblenextarg}[1]
{\ensuremath{,\:{#1}}\@ifnextchar\bgroup{\lmtuple@gobblenextarg}{\ensuremath{)}}}
\makeatother

\newcommand{\FuncTuple}[1]{\FuncSty{#1}\lmtuple}
\newcommand{\DataTuple}[1]{\DataSty{#1}\lmtuple}

\makeatletter
\newcommand{\lmset}[1]{%
  \{\ensuremath{#1}\lmset@checknextarg}
\newcommand{\lmset@checknextarg}
{\@ifnextchar\bgroup{\lmset@gobblenextarg}{\}}}
\newcommand{\lmset@gobblenextarg}[1]
{\ensuremath{,\:{#1}}\@ifnextchar\bgroup{\lmset@gobblenextarg}{\}}}
\makeatother

\makeatletter
\newcommand{\lmseq}[1]{%
  \ensuremath{#1}\lmseq@checknextarg}
\newcommand{\lmseq@checknextarg}
{\@ifnextchar\bgroup{\lmseq@gobblenextarg}{}}
\newcommand{\lmseq@gobblenextarg}[1]
{\ensuremath{;\:{#1}}\@ifnextchar\bgroup{\lmseq@gobblenextarg}{}}
\makeatother

\makeatletter
\newcommand{\lmlist@begin}{(}
\newcommand{\lmlist@end}{)}
\newcommand{\lmlist@sep}{\ }
\newcommand{\lmlist}[1]{%
  \lmlist@begin{#1}\lmlist@checknextarg}
\newcommand{\lmlist@checknextarg}
{\@ifnextchar\bgroup{\lmlist@gobblenextarg}{\lmlist@end}}
\newcommand{\lmlist@gobblenextarg}[1]
{\lmlist@sep{#1}\@ifnextchar\bgroup{\lmlist@gobblenextarg}{\lmlist@end}}
\makeatother



% \newcommand{\lmlist}[0]{\sequence}
% \newcommand{\lmlistempty}[0]{{\seqbegin\seqend}}

\makeatletter
\newcommand{\lmcall}[1]{%
  \ensuremath{#1}\lmcall@checknextarg}
\newcommand{\lmcall@checknextarg}
{\@ifnextchar\bgroup{\lmcall@gobblenextarg}{}}
\newcommand{\lmcall@gobblenextarg}[1]
{\ensuremath{\ {#1}}\@ifnextchar\bgroup{\lmcall@gobblenextarg}{}}
\makeatother

\makeatletter
\newcommand{\lmpcall}[1]{%
  \ensuremath{\left(#1}\lmpcall@checknextarg}
\newcommand{\lmpcall@checknextarg}
{\@ifnextchar\bgroup{\lmpcall@gobblenextarg}{}}
\newcommand{\lmpcall@gobblenextarg}[1]
{\ensuremath{\ {#1}}\@ifnextchar\bgroup{\lmpcall@gobblenextarg}{\right)}}
\makeatother

\makeatletter
\newcommand{\lmprod}[1]{%
  \ensuremath{#1}\lmprod@checknextarg}
\newcommand{\lmprod@checknextarg}
{\@ifnextchar\bgroup{\lmprod@gobblenextarg}{}}
\newcommand{\lmprod@gobblenextarg}[1]
{\ensuremath{\:\times\:{#1}}\@ifnextchar\bgroup{\lmprod@gobblenextarg}{}}
\makeatother

\newcommand{\lmeval}[2]{\ensuremath{{#1}\leadsto{#2}}}

\newcommand{\lmop}[0]{\boldsymbol{{\color{primarycolor}{\lambda}}}}
\newcommand{\lmopx}[0]{\boldsymbol{{\lambda}}}
\newcommand{\lmdot}[0]{\boldsymbol{.}}
\newcommand{\lmdef}[2]{{\lmop} {#1}\,\lmdot\,{#2}}
\newcommand{\lmdefx}[2]{{\lmopx} {#1}\,\lmdot\,{#2}}
\newcommand{\lmpdefx}[2]{\left({\lmopx} {#1}\,\lmdot\,{#2}\right)}
\newcommand{\lmdefp}[2]{\lmop #1\,\lmdot\,\left(#2\right)}
\newcommand{\lmpdef}[2]{\left(\lmop #1\,\lmdot\,#2\right)}

\newcommand{\lmtype}[2]{{{#1}:\,{#2}}}
\newcommand{\lmptype}[2]{\lmtype{\left(#1\right)}{#2}}
\newcommand{\lmtypep}[2]{\left(\lmtype{#1}{#2}\right)}
\newcommand{\lmtypetext}[2]{\lmtype{#1}{\DataSty{#2}}}
\newcommand{\lmtypeptext}[2]{\lmtypep{#1}{\DataSty{#2}}}
\newcommand{\lmlisttype}[1]{#1\; \DataSty{list}}
\newcommand{\lmunknowntype}[0]{\boldsymbol{?}}



\newcommand{\lmkwx}[1]{\ensuremath{\mathsf{\mathbf{#1}}}}
\newcommand{\lmkw}[1]{\lmkwx{{\color{primarycolor}{#1}}}}

\newcommand{\lmtxt}[1]{\ensuremath{\mathtt{#1}}}


\newcommand{\lmkwnc}[1]{\ensuremath{\mathsf{#1}}}

\newcommand{\lmtruex}[0]{\lmkwx{true}}
\newcommand{\lmfalsex}[0]{\lmkwx{false}}

\newcommand{\lmtrue}[0]{\lmkw{true}}
\newcommand{\lmfalse}[0]{\lmkw{false}}

% 1: variable
% 2: value
% 3: body
\newcommand{\lmlet}[3]{%
  \ensuremath{%
    \lmkw{let}\ {{#1}\leftarrow{#2}}\ \lmkw{in}\ #3}%
}

\newcommand{\lmletnc}[3]{%
  \ensuremath{%
    \lmkwnc{let}\ {{#1}\leftarrow {#2}}\ \lmkwnc{in}\ #3}%
}

% 1: name
% 2: value
\newcommand{\lmassign}[2]{%
  \ensuremath{ %
    \lmkw{var}\ #1 \leftarrow #2;%
  }
}

% 1: name
% 2: param
% 3: fun body
% 4: flet body
\newcommand{\lmflet}[4]{%
  \ensuremath{%
    \lmkw{flet}\ #1\left(#2\right) \rightarrow #3\ \lmkw{in}\ #4}%
}

% 1: name
% 2: param
% 3: fun body
\newcommand{\lmdefun}[3]{%
  \ensuremath{
    \lmkw{defun}\ #1\left(#2\right) \rightarrow #3;
  }
}

\newcommand{\lmletrec}[4]{%
  \ensuremath{
    \textbf{letrec } #1\left(#2\right) = #3 \textbf{ in } #4
  }
}

\newcommand{\lmif}[3]{%
  \ensuremath{
    \lmkw{if}\ #1 \ \lmkw{then}\ #2\ \lmkw{else}\ #3
  }
}

% \newcommand{\lmlist}[1]{%
%   \ensuremath{
%     \textbf{list}\left(#1\right)
%   }
% }

\newcommand{\lmdefstruct}[2]{%
  \ensuremath{
    \textbf{defstruct}\,#1\left(#2\right)
  }
}

\newcommand{\lmycomb}[0]{%
  \ensuremath{\mathbf{Y}}
}

\newcommand{\lmfixcomb}[0]{%
  \ensuremath{\mathbf{fix}}
}

\newcommand{\lmchurchzero}[0]{%
  \lmdef{s\,z}{z}
}

\newcommand{\lmchurchone}[0]{%
  \lmdef{s\,z}{s\,z}
}

\newcommand{\lmchurchtwo}[0]{%
  \lmdef{s\,z}{s\,(s\,z)}
}

% \newcommand{\tmhead}[2][]{%
%   \draw[faedge,#1]
%   node[node distance=2em,font=\scriptsize] {head}
%   edge (#2);
% }

\newcommand{\lmunit}[0]{\FuncSty{unit}}
\newcommand{\lmunittype}[0]{\DataSty{Unit}}

\newcommand{\lmref}[1]{\FuncSty{ref}\, {#1}}
\newcommand{\lmreftype}[1]{\DataSty{Ref}\, {#1}}

\newcommand{\lmderef}[1]{\FuncSty{deref}\, {#1}}

\newcommand{\lmasref}[2]{\ensuremath{{#1}\Leftarrow{#2}}}



%%%%%%%%%%%%%%%%%
%% Algorithm2e %%
%%%%%%%%%%%%%%%%%

\usepackage[algoruled,vlined,linesnumbered]{algorithm2e}

\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{angrycolor}{#1}}
\newcommand\mykwfont[1]{\footnotesize{\textbf{\textcolor{primarycolor}{#1}}}}
\newcommand\myargsty[1]{\footnotesize{\textrm{\textup{\textcolor{red}{#1}}}}}

\SetCommentSty{mycommfont}
\SetKwSty{mykwfont}

\SetKwProg{Fn}{function}{\ is}{end}


\makeatletter
\newcommand{\fnxlist}[1]{%
\ensuremath{#1}\fnxlist@checknextarg}
\newcommand{\fnxlist@checknextarg}
{\@ifnextchar\bgroup{\fnxlist@gobblenextarg}{}}
\newcommand{\fnxlist@gobblenextarg}[1]
{\ensuremath{,\;{#1}}\@ifnextchar\bgroup{\fnxlist@gobblenextarg}{}}
\makeatother
\newcommand{\Fnx}[3]{\Fn{\FuncSty{#1}\ensuremath{(\fnxlist#2)}}{#3}}



\newcommand\AssignOp[0]{\ensuremath{\leftarrow}}
\newcommand\Assign[2]{%
  {\ensuremath{{#1}\AssignOp{#2}}}%
}

\SetKwProg{Let}{let}{\ in}{end}
\newcommand{\LetAssign}[3]{
   \Let{\Assign{#1}{#2}}{#3}
}

\newcommand{\LetDef}[2]{\KwSty{let}{ \Assign{#1}{#2}}}

\SetKwIF{LetSeq}{LetElseIfx}{LetBody}{let}{}{XXX}{in}{end let}
\newcommand{\NLet}[2]{
  \uLetSeq{}
  {#1}
  \LetBody{
    {#2}
  }
}

\newcommand{\lNLet}[2]{
  \uLetSeq{}
  {#1}
  \lLetBody{#2}
  %\KwSty{in} {#2}
}


\SetKwProg{Match}{match}{{ with}}{end}



% \SetKwProg{MatchCase}{case}{{ \ensuremath{\rightarrow}}}{end}

\SetKwIF
{MatchCase}{MatchCaseXXX}{MatchOtherwise}
{case}{$\ensuremath{\rightarrow}$}{XXX}{otherwise}{end match}

\SetKwIF
{MatchCaseAltStart}{MatchCaseAlt}{MatchCaseAltEnd}
{case}{}{\ensuremath{|\ }}{\ensuremath{\rightarrow}}{end match}

\newcommand{\Type}[2]{\KwSty{type} {#1} $\leftarrow$ {#2}}


\SetKwProg{Variant}{type}{{ $\leftarrow$}}{end}

\SetKwIF
{VariantCase}{VariantCaseXXX}{VariantOtherwise}
{\ensuremath{|\ }}{\KwSty{of}}{XXX}{\ensuremath{|\ }}{end match}
\newcommand\VariantElt[2]{%
  %\ensuremath{|\ }{#1} \KwSty{of} {#2}
  \lVariantCase{\DataSty{#1}}{#2}
}

\newcommand\VariantProd[2]{%
  %\ensuremath{|\ }{#1} \KwSty{of} {#2}
  \lVariantCase{\DataSty{#1}}{\lmprod#2}
}

\newcommand\VariantUnit[1]{%
  %\ensuremath{|\ }{#1} \KwSty{of} {#2}
  \lVariantOtherwise{#1}
}

\makeatletter
\newcommand{\arglist}[1]{%
\ensuremath{#1}\arglist@checknextarg}
\newcommand{\arglist@checknextarg}
{\@ifnextchar\bgroup{\arglist@gobblenextarg}{}}
\newcommand{\arglist@gobblenextarg}[1]
{\ensuremath{\;{#1}}\@ifnextchar\bgroup{\arglist@gobblenextarg}{}}
\makeatother

\newcommand{\PatternWild}[0]{\ensuremath{\boldsymbol{\_}}}
\newcommand{\PatternTag}[1]{{#1}\ensuremath{\ }\arglist}

%\SetKwProg{Loop}{loop}{}{end}
%\SetKwBlock{Loop}{loop}{}{end}


\newcommand\Car[1]{\KwSty{car}{\ensuremath{\left(#1\right)}}}
\newcommand\Cdr[1]{\KwSty{cdr}\ensuremath{\left(#1\right)}}
\newcommand\Second[1]{\KwSty{second}\ensuremath{\left(#1\right)}}
\newcommand\Third[1]{\KwSty{third}\ensuremath{\left(#1\right)}}

% \SetKwFunction{Pop}{pop}
% \SetKwFunction{Car}{car}
% \SetKwFunction{First}{first}
% \SetKwFunction{Rest}{rest}
% \SetKwFunction{Second}{second}
% \SetKwFunction{Third}{third}

\SetKwFunction{Last}{last}
\SetKwFunction{Reverse}{reverse}

\SetKwFunction{Append}{append}
\SetKwFunction{Empty}{empty}
\SetKwFunction{First}{first}
\SetKwFunction{Rest}{rest}
% \newcommand\First[1]{\KwSty{first}{\ensuremath{\left(#1\right)}}}
% \newcommand\Rest[1]{\KwSty{rest}\ensuremath{\left(#1\right)}}

\newcommand\Cons[2]{\FuncSty{cons}\ensuremath{\left(#1,\ #2\right)}}
\newcommand\Nil[0]{\KwSty{NIL}}
\newcommand\T[0]{\KwSty{t}}
\newcommand\Call[2]{\ensuremath{\FuncSty{#1}\left(#2\right)}}
\newcommand\Push[2]{\ensuremath{\FuncSty{push}\left(#1,\ #2\right)}}
\newcommand\Pop[1]{\FuncSty{pop}{\ensuremath{\left(#1\right)}}}
\newcommand\Peek[1]{\FuncSty{peek}{\ensuremath{\left(#1\right)}}}
\newcommand\Enqueue[2]{\ensuremath{\FuncSty{enqueue}\left(#1,\ #2\right)}}
\newcommand\Dequeue[1]{\ensuremath{\FuncSty{dequeue}\left(#1\right)}}
\newcommand\PeekDequeue[1]{\ensuremath{\texttt{peek-dequeue}\left(#1\right)}}


\SetKwFunction{Containsx}{contains}
\newcommand\Contains[2]{\Containsx{#1,#2}}
%\newcommand\Last[1]{\ensuremath{\texttt{Last}\left(#1\right)}}

%\newcommand\List[1]{\KwSty{map}\ensuremath{\left(#1, #2\right)}}
\newcommand\Map[2]{\KwSty{map}\ensuremath{\left(#1, #2\right)}}
\newcommand\Apply[2]{\KwSty{apply}\ensuremath{\left(#1, #2\right)}}
\newcommand\FoldLeft[3]{\KwSty{fold-left}\ensuremath{\left(#1, #2, #3\right)}}

\newcommand\ReturnFrom[2]{
  \KwSty{return-from}\ensuremath{\ \texttt{#1}\ #2}
}

\newcommand\KwTrue[0]{\KwSty{true}}
\newcommand\KwFalse[0]{\KwSty{false}}

\newcommand{\FuncReturn}[0]{\Return}
\newcommand{\ImpReturn}[0]{\Return}

%%%%%%%%%%%%%%%%%%%%%
%% Time Complexity %%
%%%%%%%%%%%%%%%%%%%%%

\newcommand{\bigO}[1]{\ensuremath{O\left({#1}\right)}}

%%%%%%%%%%
%% PDDL %%
%%%%%%%%%%

% \newcommand{\pddlvar}[1]{\texttt{#1}}
% \newcommand{\pddlfun}[2]{\ensuremath{\pddlvar{#1}\left(#2\right)}}
% \newcommand{\pddlpred}[2]{\pddlvar{#1}\left(#2\right)}

\newcommand{\pddlvar}[1]{\folid{#1}}
\newcommand{\pddlpre}[1]{\folfun{pre}{#1}}
\newcommand{\pddleff}[1]{\folfun{eff}{#1}}
\newcommand{\pddlfun}[2]{\folfun{#1}{#2}}
\newcommand{\pddlpred}[2]{\folfun{#1}{#2}}
\newcommand{\pddlfunx}[2]{\folfun{#1}{\folid{#2}}}

\lstdefinelanguage{pddl}%
  {keywords={
    define,
    and,
    or,
    not,
    exists,
    forall
   },%
   morekeywords={[2]
    init,
    goal,
    precondition,
    effect,
    requirements,
    types,
    predicates,
    parameters,
    domain,
    problem,
    objects,
    derived,
    functions,
    constants,
  },%
   morekeywords={[3]
     action
   },%
   sensitive,% ???
   alsodigit={-,:,=},%
   morecomment=[l];,%
   morecomment=[s]{\#|}{|\#},% 1997 Aslak Raanes
   morestring=[b]"%
  }[keywords,comments,strings]%

\lstdefinestyle{pddlstyle}
{ %numbers=left,
  %numberstyle=\tiny,
  numbersep=4pt,
  keywordstyle={\bf},
  keywordstyle={[2]\bf\color{blue!50!black}},
  keywordstyle={[3]\bf\color{red!50!black}},
  %identifierstyle=\color{red},
  commentstyle=\color{green!50!black}
}


\newcommand{\listpddl}[1]{%
  \lstset{style=pddlstyle}
  \lstinputlisting[columns=fixed,language=pddl,
  style=pddlstyle,
  basicstyle=\scriptsize]
  {#1}
}




%%%%%%%%%%%%
%% DIMACS %%
%%%%%%%%%%%%

\lstdefinelanguage{dimacs}%
{
   morecomment=[l]{{c}},%
   morestring=[s]{cn}{f},%
   keywords={
     p, s, v
   },%
  %  morekeywords={[2]
  %   init,
  %   goal,
  %   precondition,
  %   effect,
  %   requirements,
  %   types,
  %   predicates,
  %   parameters,
  %   domain,
  %   problem,
  %   objects,
  %   derived,
  %   functions,
  %   constants,
  % },%
  %  morekeywords={[3]
  %    action
  %  },%
   sensitive,% ???
   % alsodigit={-,:,=},%
   % morecomment=[s]{\#|}{|\#},% 1997 Aslak Raanes
   % morestring=[b]"%
  }[keywords,comments,strings]%



%%%%%%%%%
%% SMT %%
%%%%%%%%%

\lstdefinelanguage{smtlib}%
{
   morecomment=[l]{{;}},%
   keywords={
     true,
     false,
     Bool,
     Int,
     declare-fun,
     assert,
     check-sat,
     get-value,
     sat,
     unsat,
   },%
  %  morekeywords={[2]
  %   init,
  %   goal,
  %   precondition,
  %   effect,
  %   requirements,
  %   types,
  %   predicates,
  %   parameters,
  %   domain,
  %   problem,
  %   objects,
  %   derived,
  %   functions,
  %   constants,
  % },%
  %  morekeywords={[3]
  %    action
  %  },%
   sensitive,% ???
   % alsodigit={-,:,=},%
   % morecomment=[s]{\#|}{|\#},% 1997 Aslak Raanes
   % morestring=[b]"%
  }[keywords,comments,strings]%